{
    "contents" : "#! /usr/bin/env Rscript\n\n# Source name : src_mapreduce/MR_Custom_Functions.R\n# Project Name: Behavior Pattern Recognition (Elance)\n# Client name : Yosef\n# Author      : mukul.biswas.ie@ieee.org\n# version     : Initial submission\n#-----------------------------------------------------------------------------------------\n# Purpose     : The program reads a number of customers-wise sales data and converts\n#               This module contains the functions used in the process of behavior\n#               Pattern Recognition. These functions are MapReduce aware and work on a\n#               distributed environment in their current form. The list of functions are -\n#               1. yoDeviation - Accepts a time-series and determines its non-stationarity\n#               2. yoCorrelation - Determines correlation between a given pair of time-\n#                   series\n#               3. yoPrediction - Predicts occurrance of sales in future N time intervals\n#               4. XPastMonthYear - A utility function returns month/year a certain period\n#                   in the past\n#-----------------------------------------------------------------------------------------\n\n\n# DETERMINE DEVIATIONS OF A TIME-SERIES ---------------------------------------------------\n# The function accepts the serial number of the file to be processed, creates a time-series\n# and performs test for stationarity (opposite of deviating). If deviating then return the\n# serial number, and the factor by with the deviation took place over last 2 years.\n#\n#\tInput\t:\tInput file denoted by the serial number\n#\tOutput\t:   A vector with 2 elements\n#               1. the serial number\n#               2. deviation factor (1 - no deviation; > 1- increasing; < 1 - decreasing)\n#\n#------------------------------------------------------------------------------------------\nyoDeviation = function(vInput, fy, fm, ly, lm){\n\t\n  tryOk = TRUE    \t\t\t\t\t\t\t# Just initialize the flag once, if fails method returns anyway\n  errcode = 0\n  tryOk = tryCatch( {\n      silent = TRUE\n      ts.data = ts(vInput, start=c(fy, fm), frequency=gTimeFreq)\n      series.components = decompose(ts.data)\t# There will be preceding and trailing NA values; 6 of them each\n      errcode = 1\n      \n      #Rest of the steps is to clear the NA value because they interfere in PP.Test. We know that NA occurs in\n      #half the frequency leading and trailing data points\n    \thalfTheFreq = gTimeFreq/2\n      \n      if(fm + halfTheFreq > 12) {\n        fm1 = fm + halfTheFreq - 12\n        fy1 = fy + 1\n      } else {\n        fm1 = fm + halfTheFreq\n        fy1 = fy\n      }\n    \t\n    \tif(lm - halfTheFreq < 1) {\n    \t  lm1 = 12 + lm - halfTheFreq\n        ly1 = ly - 1\n    \t} else {\n    \t  lm1 = lm - halfTheFreq\n        ly1 = ly\n    \t}\n      \n      final_trend = window(series.components$trend, start=c(fy1, fm1), end=c(ly1, lm1))\n      errcode = 2\n      \n\t    # Check deviation parameters, see if the trend is not stationary using PP.test and Box.test\n      pp.result = PP.test(final_trend)\n      errcode = 3\n  \n      isDeviating = FALSE              #Initializing\n    \t\n      if(pp.result$p.value > 0.05){\n    \t\t\tisDeviating = TRUE\n      \t} else {\n          box.result = Box.test(final_trend, lag=20, type=\"Ljung-Box\")\n          errcode = 4\n    \t\t  if(box.result$p.value > 0.05) isDeviating = TRUE\n    \t}\n    },\n    error = function(e) {\n      if(errcode == 0) print(\"Error: in decomposition\")\n      if(errcode == 1) print(\"Error: in window method\")\n      if(errcode == 2) print(\"Error: in PP.Test\")\n      if(errcode == 3) print(\"Error: in Box.test\")\n      if(errcode == 4) print(\"Unknown Error\")\n      return(FALSE)\n    }\t)\n    \n    if(tryOk == FALSE) return(list(FALSE, 0))\n  \n  \n\t\n\t# If the trend is deviating then determine the rate of ascend or descend\n\tif(isDeviating){\n\t  this.year.mean = mean(window(final_trend, start=c(ly-1, fm), end=c(ly,  lm)))\n\t\tlast.year.mean = mean(window(final_trend, start=c(fy-2, fm), end=c(ly-1, lm)))\n\t\t\n\t\tchange.fact = this.year.mean/last.year.mean\t\t                    # signifies +ve or -ve swing\n\t\trm(isDeviating, final_trend, series.components)\t\t                # no sure if there is a GC in R\n\t\treturn(list(TRUE, change.fact))\n  } \n} #end function\n\n\n# DETERMINATION of CORRELATION BETWEEN 2 TIME-SERIES---------------------------------------\n# Function finds correlation between 2 series\n# Arguments: The series by deviant customer serial numbers (0,1,2, ...)\n# Returns  : A vector with series 1 serial, series 2 serial, correlation coefficient if \n#            relevant return with 0,0,0 values means ignore.\n#------------------------------------------------------------------------------------------\nyoCorrelation = function(ts.i, ts.j) {\n  corcoff = cor( ts.i, ts.j, use=\"pairwise.complete.obs\", method=\"kendall\")\n  if(corcoff > MAX_RHO_LIMIT) return(corcoff) else return(NULL)\n}\n\n\n# PREDICTION OF FUTURE OCCURRENCES OF SALES -----------------------------------------------\n# The function accepts the serial number of the file to be processed, creates a time-series\n# and performs test for stationarity (opposite of deviating). If deviating then return the\n# serial number, and the factor by with the\n#\n# Arguments\t:\tThe time-series data\n# Returns\t:\tA vector with 2 elements\n#\t\t\t\t1. the serial number\n#\t\t\t\t2. deviation factor (1 - no deviation; > 1- increasing; < 1 - decreasing)\n#\n#------------------------------------------------------------------------------------------\nyoPrediction = function(tsdata, numFc = 6){\n  library(forecast)\n  \n  tryOk = TRUE\n  tryOk = tryCatch( {\n     fit = auto.arima(tsdata) \t\t\t\t# arima(amt.agg.ts.lim, c=(0,2,2))\n    \n    fore.fit = forecast(fit, numFc)\n    silent = TRUE\n  },\n  error = function(e) {\n    print(\"Error: in Auto Arima\")\n    return(FALSE)\n  }\n  )# end of tryCatch\n  \n  \n  if(tryOk == FALSE) {\n    foo = numeric(length = numFc)\n    return(c(i, foo))\n  } else {\n    return(c(i, fore.fit$mean))\n  }\n}\n\n# Function 3: getSalesDataByCustomerIdFromDfs\n#       Extracts one time-series from the data-frame containing all the time-series -\n# Arguments:    customer ID\n# Returns:      Time-series for a given customer ID\n# This function should be called only after the main program as once created the time.series\n# data-frame object\n#------------------------------------------------------------------------------------------\ngetSalesDataByCustomerIdFromDfs = function(cust.id){\n    tmpVector = numeric()\n    one.time.series = mapreduce(\n        input         =  time.series,\n        input.format  =  make.input.format(\"csv\", sep = \",\", col.names=c(\"CustNo\", \"fy\", \"fm\", \"ly\", \"lm\", \"Amount\")),\n        #output        =  file.path(\"one_time_series.txt\"),\n        output.format =  make.output.format(\"csv\", sep = \",\"),\n        \n        map = function(k,v) keyval(v$CustNo, v$Amount),\n        reduce = function(k, v) if(as.numeric(k) == cust.id) keyval(k, v)\n     )\n    # bringing timeseries to the local memory. it should not hamper performance because each timeseries\n    # itself is not big.\n    tmpList  = from.dfs(one.time.series, format=\"csv\")    # type: text; format: {NULL} {key,value}\n    tmpKeyVals = tmpList$val$V1                             # type: text; format: {key,value}\n    for(item in tmpKeyVals) {\n        tmpVector = c(tmpVector, as.numeric(strsplit(as.character(item),\",\")[[1]][2]))\n    }\n    return(tmpVector)\n}\n\n# DETERMINES MONTH-YEAR IN THE PATH -------------------------------------------------------\n# Arguments:    The reference month and year, period lapsed, number of observations\n# Returns:      A vector of resultant month and year\n# \n# Note: obs.period is in years\n#------------------------------------------------------------------------------------------\n\nXPastMonthYear = function(last.year, last.mnth, obs.period=3, num.obs=36){\n  frst.mnth = 0\n  frst.year = 0\n  if(num.obs >= obs.period*12){\n    if(last.mnth == 12) {\n      frst.mnth = 1\n      frst.year = last.year - obs.period + 1\n    } else {\n      frst.mnth = last.mnth + 1\n      frst.year = last.year - obs.period\n    }\n  } else {\n    m = num.obs %%  12\n    y = num.obs %/% 12\n    frst.mnth = last.mnth - m + 1\n    frst.year = last.year - y\n    if(frst.mnth == 0){\n      frst.mnth = 12\n      frst.year = frst.year - 1 \n    }\n    if(frst.mnth == 13){\n      frst.mnth = 1\n      frst.year = frst.year + 1 \n    }\n    \n  }\n  \n  return(c(frst.year,frst.mnth))\n}\n",
    "created" : 1398688445565.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1379534846",
    "id" : "465F1589",
    "lastKnownWriteTime" : 1398680488,
    "path" : "~/GitHub/rhadoop-sales-prediction/emr-version/MR_Custom_Functions.R",
    "project_path" : "MR_Custom_Functions.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}